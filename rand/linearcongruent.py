import matplotlib.pyplot as plt
import time
import argparse
from typing import List, Union
from pydantic import validate_call

class RandomGenerator:
    """
    Utility class for generating pseudo-random numbers using the Linear Congruent Method (LCM).
    """

    # Counter for the number of generated random numbers
    # This is a class variable, shared across all instances of the class.
    count: int = 0

    @validate_call
    def __init__(self, seed: Union[int, None] = None, M: int = 2**32, a: int = 1_664_525, c: int = 1_013_904_223):
        """
        Constructor of the class. The default values for the M, a, and c parameters follow those
            recommended by Numerical Recipes. The seed, if left blank, will assume a time-based default seed.
        Args:
            seed (int): The seed value.
            M (int): The modulus (M > 0).
            a (int): The multiplier.
            c (int): The increment.
        """
        if seed is None: seed = time.time_ns() % M

        if not (M > 0):                  raise ValueError("M must be greater than 0.")
        if not (0 < a and a < M):        raise ValueError("a must be in the range (0, M).")
        if not (0 <= c and c < M):       raise ValueError("c must be in the range [0, M).")
        if not (0 <= seed and seed < M): raise ValueError("seed must be in the range [0, M).")

        self.seed = seed
        self.a = a
        self.c = c
        self.M = M
        self.history: List[Union[int, float]] = [seed]
    
    def next(self) -> int:
        """
        Generates the next random number.
        Returns:
            int: The next random number.
        """
        self.seed = (self.a * self.seed + self.c) % self.M
        self.history.append(self.seed)
        RandomGenerator.count += 1
        return self.seed
    
    def next_normalized(self) -> float:
        """
        Generates the next random number in the range [0, 1).
        Returns:
            float: The next random number in the range [0, 1).
        """
        generated: int = self.next()
        normalized: float = generated / self.M
        self.history[-1] = normalized
        return normalized

    @validate_call
    def next_in_range(self, min: float, max: float) -> float:
        """
        Generates the next random number in the range [min, max).
        Args:
            min (float): The lower bound of the range.
            max (float): The upper bound of the range.
        Returns:
            float: The next random number in the provided range.
        """
        normalized: float = self.next_normalized()
        ranged: float = min + ((max-min) * normalized)
        self.history[-1] = ranged
        return ranged
    
    def plot_all(self):
        """
        Plots all the pseud-random numbers generated by this class instance.
        """
        plt.figure(figsize=(10,5))
        plt.plot(self.history, marker="o", linestyle="", markersize=3, label="Generated numbers")
        plt.xlabel("Iteration")
        plt.ylabel("Pseudo-random")
        plt.ylim(0, 1)
        plt.title("Linear Congruational Generator Pseudo-Randoms")
        plt.grid(True)
        plt.show()

def main():
    parser = argparse.ArgumentParser(description="Linear Congruential Random Number Generator")
    parser.add_argument("-q", "--quantity", type=int, default=1_000, help="Quantity of pseud-random numbers to generate")
    args = parser.parse_args()

    lcrg = LinearCongruentRandomGenerator()

    print("Generating random numbers...")
    with open("randoms.txt", "w") as f:
        for i in range(args.quantity):
            rnd = lcrg.next_normalized()
            f.write(f"{rnd}\n")
    
    print("Plotting the generated numbers...")
    lcrg.plot_all()

if __name__ == "__main__":
    main()